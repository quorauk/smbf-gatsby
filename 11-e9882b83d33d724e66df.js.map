{"version":3,"sources":["webpack:///../src/components/intersection-observer.ts","webpack:///./node_modules/gatsby/node_modules/core-js/modules/_collection-weak.js","webpack:///./node_modules/gatsby/node_modules/core-js/modules/es6.weak-map.js"],"names":["intersectionObserver","ioEntryMap","WeakMap","connection","navigator","mozConnection","webkitConnection","createIntersectionObserver","callback","window","IntersectionObserver","entries","forEach","entry","isIntersecting","get","target","rootMargin","effectiveType","saveData","element","current","set","observe","unobserve","redefineAll","getWeak","anObject","isObject","anInstance","forOf","createArrayMethod","$has","validate","arrayFind","arrayFindIndex","id","uncaughtFrozenStore","that","_l","UncaughtFrozenStore","this","a","findUncaughtFrozen","store","key","it","prototype","has","value","push","index","splice","module","exports","getConstructor","wrapper","NAME","IS_MAP","ADDER","C","iterable","_t","_i","undefined","data","def","ufstore","InternalMap","global","each","redefine","meta","assign","weak","NATIVE_WEAK_MAP","IS_IE11","ActiveXObject","isExtensible","Object","arguments","length","methods","$WeakMap","NEED","proto","method","b","_f","result","call"],"mappings":"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","file":"11-e9882b83d33d724e66df.js","sourcesContent":["/* eslint-disable no-unused-expressions */\nimport { RefObject } from \"react\"\n\nlet intersectionObserver: IntersectionObserver\n\nexport type Unobserver = () => void\n\nconst ioEntryMap = new WeakMap<HTMLElement, () => void>()\n/* eslint-disable @typescript-eslint/no-explicit-any  */\nconst connection =\n  (navigator as any).connection ||\n  (navigator as any).mozConnection ||\n  (navigator as any).webkitConnection\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n// These match the thresholds used in Chrome's native lazy loading\n// @see https://web.dev/browser-level-image-lazy-loading/#distance-from-viewport-thresholds\nconst FAST_CONNECTION_THRESHOLD = `1250px`\nconst SLOW_CONNECTION_THRESHOLD = `2500px`\n\nexport function createIntersectionObserver(\n  callback: () => void\n): (element: RefObject<HTMLElement | undefined>) => Unobserver {\n  const connectionType = connection?.effectiveType\n\n  // if we don't support intersectionObserver we don't lazy load (Sorry IE 11).\n  if (!(`IntersectionObserver` in window)) {\n    return function observe(): Unobserver {\n      callback()\n      return function unobserve(): void {}\n    }\n  }\n\n  if (!intersectionObserver) {\n    intersectionObserver = new IntersectionObserver(\n      entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            // Get the matching entry's callback and call it\n            ioEntryMap.get(entry.target as HTMLElement)?.()\n            // We only need to call it once\n            ioEntryMap.delete(entry.target as HTMLElement)\n          }\n        })\n      },\n      {\n        rootMargin:\n          connectionType === `4g` && !connection?.saveData\n            ? FAST_CONNECTION_THRESHOLD\n            : SLOW_CONNECTION_THRESHOLD,\n      }\n    )\n  }\n\n  return function observe(\n    element: RefObject<HTMLElement | undefined>\n  ): Unobserver {\n    if (element.current) {\n      // Store a reference to the callback mapped to the element being watched\n      ioEntryMap.set(element.current, callback)\n      intersectionObserver.observe(element.current)\n    }\n\n    return function unobserve(): void {\n      if (intersectionObserver && element.current) {\n        ioEntryMap.delete(element.current)\n        intersectionObserver.unobserve(element.current)\n      }\n    }\n  }\n}\n","'use strict';\nvar redefineAll = require('./_redefine-all');\nvar getWeak = require('./_meta').getWeak;\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar createArrayMethod = require('./_array-methods');\nvar $has = require('./_has');\nvar validate = require('./_validate-collection');\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n","'use strict';\nvar global = require('./_global');\nvar each = require('./_array-methods')(0);\nvar redefine = require('./_redefine');\nvar meta = require('./_meta');\nvar assign = require('./_object-assign');\nvar weak = require('./_collection-weak');\nvar isObject = require('./_is-object');\nvar validate = require('./_validate-collection');\nvar NATIVE_WEAK_MAP = require('./_validate-collection');\nvar IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (NATIVE_WEAK_MAP && IS_IE11) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n"],"sourceRoot":""}